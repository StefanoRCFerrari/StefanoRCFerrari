Lesson: Derivation and Bisection Method in JavaScript

In this lesson, we will walk through a JavaScript program that accepts a polynomial, calculates its derivative, and then uses the Bisection Method to find critical points (where the derivative is zero) within a specified interval.

This breakdown explains the logic and structure of the code while reinforcing the mathematical concepts at play.

Key Concepts Involved

Polynomial Differentiation:

The process of finding the derivative of a polynomial.

Bisection Method:

A numerical method to find roots of continuous functions by repeatedly halving an interval.

Critical Points:

Points where the derivative of a function equals zero, which is useful in optimization problems (e.g., finding maximum or minimum values).

Detailed Breakdown of the Code
1. Polynomial Parsing and Differentiation

Polynomial Parsing:
The code starts by accepting a polynomial input in the form of a string. The string is then parsed into individual terms using regular expressions and string manipulation functions. This parsing process breaks down a polynomial like "3x^2 - 5x + 2" into terms like ['+3x^2', '-5x', '+2'].

Differentiation of Terms:
Each term in the polynomial is then differentiated individually. For instance:

3x^2 becomes 6x.

-5x becomes -5.

+2 (a constant) becomes 0.

The differentiation follows the general rule:

𝑑
𝑑
𝑥
(
𝑎
𝑥
𝑛
)
=
𝑎
⋅
𝑛
⋅
𝑥
𝑛
−
1
dx
d
	​

(ax
n
)=a⋅n⋅x
n−1

Where:

𝑎
a is the coefficient.

𝑛
n is the exponent.

This step is crucial because critical points occur where the derivative equals zero, so we need to compute the derivative of the function first.

2. Evaluating the Derivative at Specific Points

After differentiating the terms, the next task is to evaluate the derivative at any given point x. This is achieved by summing the contributions of each term at the specified x value.

3. Bisection Method for Finding Critical Points

Now, let's dive into the Bisection Method. The critical idea is to find where the derivative changes sign in a given interval [a, b], which suggests the existence of a root (i.e., where the derivative equals zero).

Checking the Interval:

The first step is to check whether the function's values at the endpoints a and b have opposite signs. If f'(a) and f'(b) are of opposite signs, we can be sure there is a root between them.

If the signs are the same, the method attempts to find a subinterval within [a, b] where the derivative changes sign.

Subinterval Search:
The subinterval search checks the entire interval [a, b] in small steps (controlled by a parameter step). It looks for points where the derivative changes signs, i.e., where f'(x) changes from positive to negative or vice versa. If no subinterval is found, the method cannot proceed.

Applying the Bisection Method:
Once a valid subinterval is found (or if the initial interval is valid), the Bisection Method starts:

The midpoint p of the interval [a, b] is computed.

The derivative at p is evaluated.

The interval is halved based on whether the derivative at the midpoint is positive or negative, narrowing down to where the derivative crosses zero.

The loop continues until either:

The derivative at p is close enough to zero (i.e., the solution is found).

The maximum number of iterations (maxIterations) is reached.

The user can specify a tolerance (epsilon) which determines the acceptable error for the root.

Code Flow Explained

Let’s now break down the code flow and the sequence of steps:

Input Parsing:

The user provides a polynomial string, such as "3x^2 - 5x + 2".

The code splits the polynomial into individual terms and then differentiates each term using the differentiateTerm function.

Derivative Calculation:

The terms are then differentiated, and the derivative is displayed in a readable format (e.g., 6x - 5).

If the polynomial is constant (no variable terms), the program informs the user that there are no critical points to be found.

Finding Critical Points:

The user is prompted to provide an interval [a, b] and a tolerance epsilon for the Bisection Method.

The program checks whether the derivative at the endpoints a and b have opposite signs. If they don’t, it attempts to find a valid subinterval where the derivative changes sign.

Bisection Method:

If a valid interval is found, the Bisection Method is applied.

The midpoint of the interval is calculated, and the function evaluates the derivative at this midpoint.

The interval is narrowed down iteratively by halving the interval based on the sign of the derivative at the midpoint.

Result Output:

Once the method converges (or reaches the maximum number of iterations), the program outputs the critical point, the number of iterations, and the final interval.

If the method doesn’t converge within the specified iterations, it outputs the best approximation found.

Mathematical Insights

Derivative and Critical Points:

A critical point is where the derivative equals zero: 
𝑓
′
(
𝑥
)
=
0
f
′
(x)=0. These points are important because they indicate where the function may have a local maximum, minimum, or inflection point.

By using the derivative of the polynomial, we can find where these critical points lie.

Bisection Method:

This method works by repeatedly halving the interval [a, b] and checking the sign of the function at the midpoint.

It guarantees convergence if the function is continuous and if there is a change of sign between f(a) and f(b). However, if there is no sign change, the method cannot proceed without a valid subinterval.

Possible Improvements and Considerations

Edge Case Handling:

The code assumes that the user will input valid polynomials and intervals. Handling cases like invalid polynomials, intervals where a is equal to b, or intervals where the derivative doesn't change sign would improve the robustness of the program.

Performance Optimizations:

For very large polynomials, performance could be improved by caching derivative calculations or optimizing how terms are parsed and differentiated.

User Experience:

Providing clearer error messages and more interactive prompts could enhance user experience, especially for those less familiar with the Bisection Method or polynomial derivatives.

Conclusion

In this lesson, we reviewed a JavaScript program that uses the Bisection Method to find critical points of a polynomial function. The program breaks down the problem into manageable tasks: parsing the polynomial, differentiating it, checking for sign changes in the derivative, and applying the Bisection Method to narrow down the location of critical points.

By understanding the concepts of polynomial differentiation and numerical methods like the Bisection Method, you can solve a variety of optimization problems in real-world scenarios.